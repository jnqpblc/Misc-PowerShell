# Unconstrained Delegation
//MATCH (c:Computer {enabled:TRUE, unconstraineddelegation:TRUE}) RETURN c.name,c.operatingsystem ORDER BY c.name ASC
MATCH (c1:Computer {enabled:"true"})-[:MemberOf*1..]->(g:Group) WHERE g.objectsid ENDS WITH "-516" WITH COLLECT(c1.name) AS domainControllers MATCH (c2:Computer {unconstraineddelegation:"true"}) WHERE NOT (c2.name IN domainControllers) RETURN c2.name, c2.operatingsystem ORDER BY c2.name ASC;

# Hunting Domains and Trusts
MATCH (d:Domain) RETURN properties(d) LIMIT 1;
MATCH (d:Domain) WHERE d.functionallevel IS NOT NULL RETURN d.name, d.functionallevel
MATCH (d:Domain)-[r]->(n) RETURN d.name, COUNT(type(r)) as count, type(r) ORDER BY count
MATCH (d:Domain)-[r:TrustedBy]->(n) RETURN d.name, type(r), n.name
MATCH (d:Domain)-[r:GpLink]->(n) RETURN d.name, type(r), n.name
MATCH (d:Domain)-[r:Contains]->(n) RETURN d.name, type(r), n.name

# Hunting Computers
MATCH (c:Computer) RETURN properties(c) LIMIT 1;
MATCH (c:Computer {enabled:TRUE}) RETURN c.domain, COUNT(c.domain) ORDER BY COUNT(c.domain) DESC
MATCH (c:Computer {enabled:TRUE}) RETURN c.domain, c.operatingsystem, COUNT(c.operatingsystem) ORDER BY COUNT(c.operatingsystem) DESC
MATCH (c:Computer {enabled:TRUE}) RETURN COUNT(c.domain), c.domain
MATCH (c:Computer {enabled:TRUE}) RETURN c.haslaps, COUNT(c.haslaps)
MATCH (c:Computer {enabled:TRUE, trustedtoauth:TRUE}) RETURN c.name, c.displayname, c.description
MATCH (c:Computer {enabled:TRUE}) WHERE NOT c.sidhistory=[] RETURN c.name, c.displayname, c.description
MATCH (c:Computer {enabled:TRUE}) WHERE NOT c.serviceprincipalnames=[] UNWIND c.serviceprincipalnames AS spn WITH spn, c RETURN SPLIT(spn, "/")[0] AS spn_type, COUNT(DISTINCT c.name) AS computer_count ORDER BY computer_count ASC;
MATCH (c:Computer {enabled:TRUE}) UNWIND c.serviceprincipalnames AS spn WITH spn, c WHERE spn =~ '(?i).*(piserver|nfs).*' RETURN c.name, c.displayname, collect(spn) AS matched_spns;
MATCH (c:Computer {enabled:TRUE}) WHERE c.lastlogontimestamp < 1 RETURN c.name, datetime({ epochSeconds: toInteger(c.whencreated) }) AS created_ts, c.distinguishedname
MATCH (c:Computer {enabled:TRUE}) WHERE c.distinguishedname IS NOT NULL WITH c, [part IN SPLIT(c.distinguishedname, ',') WHERE part STARTS WITH 'OU='] AS ou_parts WITH c, REVERSE(ou_parts) AS ou_parts_reversed WITH c, REDUCE(s = '', part IN ou_parts_reversed | s + CASE WHEN s <> '' THEN ' / ' ELSE '' END + REPLACE(part,'OU=','')) AS ou_path RETURN COUNT(c) AS count, ou_path ORDER BY ou_path ASC;
// Calculate 3 months ago in Unix timestamp (approx. 90 days)
WITH timestamp() / 1000 AS now_seconds, (timestamp() / 1000) - 90*24*60*60 AS cutoff
MATCH (c:Computer {enabled:TRUE}) WHERE c.pwdlastset IS NOT NULL AND c.pwdlastset < cutoff RETURN c.name, c.operatingsystem, datetime({epochSeconds: toInteger(c.pwdlastset)}) as pwdlastset ORDER BY pwdlastset ASC;
//Possible PreWin2k Computer Accounts
MATCH (c:Computer {enabled:TRUE}) WHERE c.pwdlastset IS NOT NULL AND c.whencreated IS NOT NULL AND NOT c.pwdlastset IN [-1.0, 0.0] AND toInteger(c.pwdlastset) = toInteger(c.whencreated) RETURN c.name AS Computer, c.domain AS Domain, datetime({ epochSeconds: toInteger(c.whencreated) }) AS created_ts, datetime({ epochSeconds: toInteger(c.pwdlastset) }) AS pwdlastset_ts, c.objectid AS ObjectID ORDER BY created_ts DESC;
//All OSes
MATCH (c:Computer {enabled:TRUE}) RETURN c.operatingsystem, COUNT(c) as count ORDER BY count ASC
MATCH (c:Computer {enabled:TRUE}) RETURN c.operatingsystemversion, COUNT(c) as count ORDER BY count ASC
//Non-Windows OSes
MATCH (c:Computer {enabled:TRUE}) WHERE NOT (toUpper(c.operatingsystem) STARTS WITH 'WINDOWS' OR toUpper(c.operatingsystem) STARTS WITH 'MAC') RETURN c.name, c.operatingsystem ORDER BY c.operatingsystem ASC
//Unsupported Windows OSes
MATCH (c:Computer {enabled:TRUE}) WHERE c.operatingsystem =~ '(?i).*(NT 3|NT 4|2000|ME|XP|2003|VISTA|Windows 7|Windows 8|2008|2012).*' RETURN c.operatingsystem, COUNT(c) ORDER BY c.operatingsystem DESC
MATCH (c:Computer {enabled:TRUE}) WHERE c.operatingsystem =~ '(?i).*(NT 3|NT 4|2000|ME|XP|2003|VISTA|Windows 7|Windows 8|2008|2012).*' RETURN c.domain, c.operatingsystem, COUNT(c) ORDER BY c.domain DESC

# Hunting Users
MATCH (u:User {enabled:TRUE}) RETURN properties(u) LIMIT 1;
MATCH (u:User {enabled:TRUE}) RETURN COUNT(u), u.domain
MATCH (u:User {enabled:TRUE}) WHERE u.userpassword IS NOT NULL RETURN u.name, u.userpassword, u.description
MATCH (u:User {enabled:TRUE, passwordnotreqd:TRUE}) RETURN u.displayname, u.name, u.description ORDER BY u.displayname ASC
MATCH (u:User {enabled:TRUE, dontreqpreauth:TRUE}) RETURN u.name, u.displayname, u.title, u.description
MATCH (u:User {enabled:TRUE, unconstraineddelegation:TRUE}) RETURN u.displayname, u.name, u.description ORDER BY u.displayname ASC
MATCH (u:User {enabled:TRUE, trustedtoauth:TRUE}) RETURN u.name, u.displayname, u.description
MATCH (u:User {enabled:TRUE, hasspn:TRUE}) RETURN u.name, u.displayname, u.title, u.description
MATCH (u:User {enabled:TRUE}) WHERE NOT u.sidhistory=[] RETURN u.name, u.displayname, u.description
MATCH (u:User {enabled:TRUE, hasspn:TRUE}) WHERE NOT u.serviceprincipalnames=[] UNWIND u.serviceprincipalnames AS spn WITH spn, u RETURN SPLIT(spn, "/")[0] AS spn_type, COUNT(DISTINCT u.name) AS count ORDER BY count ASC;
MATCH (u:User{enabled:TRUE}) UNWIND u.serviceprincipalnames AS spn WITH spn, u WHERE spn =~ '(?i).*(MSSQLSvc|HTTP).*' RETURN u.name, u.displayname, collect(spn) AS matched_spns;
MATCH (u:User {enabled:TRUE}) WHERE u.lastlogontimestamp < 1 RETURN u.name, datetime({ epochSeconds: toInteger(u.whencreated) }) AS created_ts, u.distinguishedname
MATCH (u:User {enabled:TRUE}) WHERE u.distinguishedname IS NOT NULL WITH u, [part IN SPLIT(u.distinguishedname, ',') WHERE part STARTS WITH 'OU='] AS ou_parts WITH u, REVERSE(ou_parts) AS ou_parts_reversed WITH u, REDUCE(s = '', part IN ou_parts_reversed | s + CASE WHEN s <> '' THEN ' / ' ELSE '' END + REPLACE(part,'OU=','')) AS ou_path RETURN COUNT(u) AS count, ou_path ORDER BY ou_path ASC;
MATCH (u:User {enabled:TRUE}) WHERE u.title IS NOT NULL RETURN count(u) as count, u.title ORDER BY count ASC
MATCH (u:User {enabled:TRUE}) WHERE u.description IS NOT NULL RETURN count(u) as count, u.description ORDER BY count ASC
MATCH (u:User {enabled:TRUE}) WHERE (u.sensitive=true OR u.admincount=true) RETURN u.displayname, u.name, u.description ORDER BY u.displayname ASC
MATCH (u:User {enabled:TRUE}) WHERE NOT u.sidhistory=[] RETURN u.name, u.displayname, u.sidhistory
// pwdneverexpires:TRUE - Calculate 1 year ago in Unix timestamp (approx. 365 days)
WITH timestamp() / 1000 AS now_seconds, (timestamp() / 1000) - 356*24*60*60 AS cutoff
MATCH (u:User {enabled:TRUE, pwdneverexpires:TRUE}) WHERE u.pwdlastset IS NOT NULL AND u.pwdlastset < cutoff RETURN datetime({epochSeconds: toInteger(u.pwdlastset)}) AS pwdlastset, u.name, u.displayname, u.title, u.description, datetime({epochSeconds: toInteger(u.lastlogontimestamp)}) AS lastlogon ORDER BY pwdlastset ASC
// pwdneverexpires:FALSE - Calculate 1 year ago in Unix timestamp (approx. 365 days)
WITH timestamp() / 1000 AS now_seconds, (timestamp() / 1000) - 356*24*60*60 AS cutoff
MATCH (u:User {enabled:TRUE, pwdneverexpires:FALSE}) WHERE u.pwdlastset IS NOT NULL AND u.pwdlastset < cutoff RETURN datetime({epochSeconds: toInteger(u.pwdlastset)}) AS pwdlastset, u.name, u.displayname, u.title, u.description, datetime({epochSeconds: toInteger(u.lastlogontimestamp)}) AS lastlogon ORDER BY pwdlastset ASC
// whencreated == pwdlastset
MATCH (u:User {enabled:TRUE}) WHERE u.pwdlastset IS NOT NULL AND u.whencreated IS NOT NULL AND NOT u.pwdlastset IN [-1.0, 0.0] AND toInteger(u.pwdlastset) = toInteger(u.whencreated) RETURN u.name AS User, u.domain AS Domain, datetime({ epochSeconds: toInteger(u.whencreated) }) AS created_ts, datetime({ epochSeconds: toInteger(u.pwdlastset) }) AS pwdlastset_ts, u.objectid AS ObjectID ORDER BY created_ts DESC;
//Relationships
MATCH p=(u:User {enabled:TRUE, admincount:FALSE})-[r:GenericAll]->() RETURN p
MATCH p=(u:User {enabled:TRUE, admincount:FALSE})-[r:AddAllowedToAct]->() RETURN p


# Hunting Groups
MATCH (g:Group) RETURN properties(g) LIMIT 1;
MATCH (n)-[r:MemberOf]->(g) WHERE g.samaccountname =~ '(?i).*(2000).*' RETURN n.name, type(r), g.name

# Hunting Other Objects
MATCH (g:GPO) RETURN properties(g) LIMIT 1;
MATCH (g:GPO) RETURN g.name, g.gpcpath ORDER BY g.name
MATCH (o:OU) RETURN properties(o) LIMIT 1;
MATCH (o:OU) RETURN o.name, o.guid, o.description ORDER BY o.name
MATCH (o:OU) RETURN count(o.name), o.name ORDER BY count(o.name) DESC
MATCH (o:OU {blocksinheritance:TRUE}) RETURN o.name, o.guid, o.description ORDER BY o.name

# Hunting Relationships
MATCH p=(n {enabled:TRUE, admincount:FALSE})-[r:GenericAll]->() RETURN p
MATCH p=(n {enabled:TRUE, admincount:FALSE})-[r:AddAllowedToAct]->() RETURN p
MATCH ()-[r]->() RETURN DISTINCT type(r) ORDER BY type(r)
MATCH (n)-[r]->() WHERE n.admincount=false RETURN count(r) AS count, type(r) AS relType ORDER BY count

	type(r)
"AddAllowedToAct"
"AddKeyCredentialLink"
"AddMember"
"AllExtendedRights"
"Contains"
"ForceChangePassword"
"GenericAll"
"GenericWrite"
"GetChanges"
"GetChangesAll"
"GetChangesInFilteredSet"
"GpLink"
"MemberOf"
"Owns"
"WriteAccountRestrictions"
"WriteDacl"
"WriteGPLink"
"WriteOwner"
"WriteSPN"

# Hunting Data
MATCH (u:User) RETURN u.homedirectory, COUNT(u.homedirectory) ORDER BY COUNT(u.homedirectory) DESC
MATCH (u:User) WHERE u.homedirectory IS NOT NULL RETURN count(u.homedirectory), u.homedirectory ORDER BY count(u.homedirectory) DESC

# Hunting Domains
MATCH (d:Domain) RETURN d
MATCH (d:Domain) RETURN d.name, d.functionallevel, d.objectid ORDER BY d.name ASC

# Research
MATCH (d:Domain) RETURN keys(d)
MATCH (u:User) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;
MATCH (u:User) WHERE u.name STARTS WITH "ADMIN" WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

# Aggregate Function Research
https://neo4j.com/docs/cypher-manual/current/functions/list/

keys()
labels()
nodes()
range()
reduce()
relationships()
reverse()
tail()

MATCH (u:User) WHERE u.name STARTS WITH "ADMIN" RETURN keys(u)

# Keys Reference
u: OU, GPO, Base, User, Group, Domain, Computer, ForeignSecurityPrincipal, 

MATCH (u:User) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"objectsid"
"lastlogontimestamp"
"dontreqpreauth"
"owned"
"pwdlastset"
"lastlogon"
"enabled"
"pwdneverexpires"
"hasspn"
"serviceprincipalnames"
"sidhistory"
"passwordnotreqd"
"sensitive"
"unconstraineddelegation"
"domain"
"admincount"
"description"
"objectid"
"name"
"highvalue"
"distinguishedname"
"displayname"
"email"
"title"
"homedirectory"
"userpassword"


MATCH (u:Computer) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"objectid"
"owned"
"name"


MATCH (u:Group) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"distinguishedname"
"admincount"
"description"
"objectsid"
"name"
"objectid"
"highvalue"
"domain"


MATCH (u:Domain) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"distinguishedname"
"objectsid"
"functionallevel"
"domain"
"name"
"objectid"
"highvalue"


MATCH (u:Foreignsecurityprincipal) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"objectid"


MATCH (u:OU) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"domain"
"name"
"guid"
"blocksinheritance"
"highvalue"
"description"


MATCH (u:GPO) WITH DISTINCT keys(u) AS keys UNWIND keys AS keyslisting WITH DISTINCT keyslisting AS allfields RETURN allfields;

"domain"
"guid"
"gpcpath"
"highvalue"
"name"

# Cleanup Data
MATCH (n) DETACH DELETE n;
//List constraints:
SHOW CONSTRAINTS;
DROP CONSTRAINT constraint_xxx;
//List indexes:
SHOW INDEXES;
DROP INDEX index_xxx;
